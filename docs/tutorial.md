
@def title = "Groebner.jl — Tutorial"
@def hasmath = true
@def hascode = true
<!-- Note: by default hasmath == true and hascode == false. You can change this in
the config file by setting hasmath = false for instance and just setting it to true
where appropriate -->

# Tutorials

```julia:installs
import Pkg # hide
import Pkg; Pkg.add("BenchmarkTools") # hide
Pkg.add("Graphs") # hide
Pkg.add("GraphPlot") # hide
Pkg.add("AbstractAlgebra") # hide
Pkg.add("Groebner") # hide
Pkg.add("DynamicPolynomials") # hide
Pkg.add("AbstractAlgebra") # hide
Pkg.add("Compose") # hide
using Groebner # hide
using AbstractAlgebra # hide
using BenchmarkTools # hide
using Graphs # hide
using GraphPlot # hide
using Compose # hide
```
## Introduction

The following contains a series of tutorials on basics and interesting usecases of Groebner bases provided with the code from `Groebner.jl`.

<!-- Introduced by Buchberger in 1965 for handling quotient space of Ideals algorithmically, Groebner bases are excellent for **variable elimination, system solving**, and many more. Among others, Groebner bases find applications in

- Robotics
- Chemical Reactions Networks Analysis
- Control Theory
- Cryptography

The following tutorials will give a short introduction to Groebner basis ground theory, and cover some random interesting showcases. -->

### So, what is Groebner basis?

*In short, a Groebner basis is a good representation of infinite information.*

Let us recall some theory from an algebra course. A set of polynomials $F = \{f_1, \ldots, f_m \}$ is said to *generate an infinite* set $I$:

\[
  I = \{ f_1h_1 + f_2h_2 + \ldots + f_nh_n ~~|~~ h_i ~arbitrary \}
\]

Such $I$ is usually called *an Ideal generated by* $\{f_i\}$. A Groebner basis of $I$ is a *nicer set of generators* for $I$. E.g., if $F$ is

```julia:aaimport
using AbstractAlgebra
_, (x, y) = QQ["x", "y"]
F = [x^3 + y^2, x*y + x^2];
```

In this example, the Groebner basis of `F` is
```julia:exampleone
using Groebner
G = groebner(F)
```

Every set of polynomials has a Groebner basis. But why is it *nice*?

First of all, the Groebner basis **is unique**! That is, if two sets of polynomials $F_1$ and $F_2$ generate the same Ideal (which is actually infinite), then their Groebner bases (which are finite) are the same and can be compared directly

```julia:unique
F₁ = [x^3 + y^3, x*y + x^2, x^3 - y^2]
F₂ = [x^3 - y^2, x*y + x^2]
groebner(F₁) == groebner(F₂)
```

So, a Groebner basis is a *unique and finite* representation for symbolic systems, combinatorial relations, and everything else that can be encoded with polynomials.

Secondly, Groebner bases allow some algebraic operations over polynomials and Ideals, which are unattainable without it. As an example, with Groebner bases we can do *multivariate polynomial division by a set* (i.e., **normal form** computation). With a polynomial $f$ and a set of polynomials $F$, one can divide $f$ by $F$ (i.e., produce a **unique** reminder of $f$ modulo $F$) by computing the normal form of $f$ w.r.t. the Groebner basis of $F$.

`Groebner.jl` provides normal form functionality with the `normalform` function.

```julia:nf
F = [x^3 + y^2, x*y + x^2]
f = x^4*y^2 + y^3 + x^2 + x*y + 1

G = groebner(F)     # compute the basis
normalform(G, f)    # "divide" f by G
```

The normal form is used in study of algebraic questions regarding Ideals: Ideal membership problem, Ideal quotient space basis finding, and a lot more.

## Gcd & Rref

Computing a Groebner basis for a general system of nonlinear equations is nontrivial, both from theoretic and computational perspectives. Still, the two widely known algorithms can give us some intuition behind this process.

### Groebner basis is Gaussian Elimination

For a **linear** system, a Groebner basis mirrors the row echelon form. That is, computing a Groebner basis is *a nonlinear generalization of Gaussian elimination* process for systems of algebraic equations.

Indeed, applied to a linear system, Groebner basis algorithms produce row echelon matrix form

```julia:gauss
using DynamicPolynomials # hide
@polyvar x y z
system = [
       x - y + z + 1,
       x + 2y + 3z + 4,
       x + y + 5z + 3
]

groebner(system)  # rref
```

and imply $z = 0, ~y = -1, ~x = -2$.

### Groebner basis is Euclidean Algorithm

In case the system is **univariate**, a Groebner basis coincides with the GCD of system generators. One can even say that computing a Groebner basis is a *multivariate generalization of applying Euclidean Algorithm*

```julia:gcd1
using DynamicPolynomials # hide
@polyvar x
f = (x^2 - 1)^7*(x + 3)*(x - 7)^4
g = (x + 3)*(x + 7)

groebner([f, g])   # gcd by groebner
```

```julia:gcd2
gcd(f, g)          # usual gcd
```

Same holds for several input polynomials:

\[
groebner(f_1, \ldots, f_m) = gcd(gcd(gcd(f_1, f_2), \ldots), f_m)
\]

So, you can compute the GCD of several polynomials at once using `Groebner.jl`!

We emphasize that `Groebner.jl` is designed to have as little runtime overhead as possible over the usual GCD implementation even for simple input.

With `DynamicPolynomials.jl`:

```julia:gcd3
h = (x + 3)^5

@btime gcd(gcd($f, $g), $h)
```

With `Groebner.jl`:

```julia:gcd4
F = [f, g, h]
@btime groebner($F)
```

## Variable Elimination

One can also use Groebner bases to *eliminate indeterminates* from equations. A layer of theory lies behind this topic, however, the main simple observation here is that

***

If $G$ is a Groebner basis of Ideal $I$ with variables ordered as $x > y > z$, then

\[
G \cap R[y, z]
\]

is a Groebner basis for $I_{y, z}~ =~ I \cap R[y, z]$.

***

Here, one can see $I_{y, z}$ as a fair geometric projection of $I$ onto the last two variables $y, z$.

For example, consider polynomial set $F$ that encodes some complicated algebraic variety in 3D:

```julia:elim1
_, (x, y, z) = QQ["x", "y", "z"]

F = [x + y^2 + z - 1,
     x + y + z^2 - 1]
```

<!-- Plotted, this variety looks like

[PLOT of in 3D] -->

Let's try to simplify it a bit. Now, the Groebner basis of $F$ is

```julia:elim2
G = groebner(F)
```

Notice that the first polynomial in  `G` does not contain `x`! The observation implies that `G[1]` is a Groebner basis of $I_{y, z}$, meaning the solutions of

\[
y^2 - y - z^2 + z = 0
\]

are exactly the projection of solutions of $F$ to variables $y$ and $z$.

<!-- Let us plot the solutions of `G[1]` -->

With this technique, one can split a complicated variety in parts, and treat each part separately.

## Curve Implicitization

Moreover, `Groebner.jl` can help converting a parametric curve representation to an implicit one. Say, we have a parametrization of *the circle on a plane*

\[
x = \frac{1 - t^2}{1 + t^2} ~~~~ y = \frac{2t}{1 + t^2}
\]

and we want to produce an implicit curve equation in $x, y$ and *without t*.

First, let's clear denominators

\[
t^2y - 2t + y = 0 ~~~~ t^2x + t^2 + x - 1 = 0
\]

The Groebner basis of the above with $t > x > y$ in lexicographic order is

```julia:impl1
using AbstractAlgebra
_, (t, x, y) = PolynomialRing(QQ, ["t", "x", "y"], ordering=:lex)

groebner([t^2*y - 2t + y, t^2*x + t^2 + x - 1])
```

There, the only two-variable equation in $x, y$ is

\[
x^2 + y^2 - 1 = 0
\]

Hence, $x^2 + y^2 - 1 = 0$ is an implicit formula we were looking for. Indeed, for any $t$ every $(x, y)$ lies on the circle as expected.

## Solving Systems

Groebner bases can be used to solve systems *exactly*, given the number of solutions is finite.

In this section we assume the usual lexicographic ordering of variables and consider the case with three variables (i.e, $x > y > z$). Same method generalizes naturally for $n$ indeterminates.

```julia:sys0
_, (x, y, z) = PolynomialRing(QQ, ["x", "y", "z"], ordering=:lex);
```

To illustrate the method, we consider the following polynomial system to solve

```julia:sys1
system = [x + y + z,
          x*y + x*z + y*z,
          x*y*z - 1];
```

Recall that the solutions of a system coincide with zeros of a Groebner basis of this system (since the original system and its basis are *equivalent*). Let's calculate a Groebner basis then!

```julia:sys2
groebner(system)
```

Notice that `z^3 - 1` in the basis is a *univariate equation*. Solving it over the desired domain one obtains some roots `z = ...`.

Then, substitute `z` into the second equation `y^2 + y*z + z^2`, which in turn becomes univariate in variable `y`. Solving it and obtaining zeros in `y`, one moves to the next equation in the basis.

Substituting each `y` and `z` to `x + y + z`, one easily produces a single solution in `x` for each solution in `y, z`.  

Solving general polynomial systems (assuming the set of solutions is finite) using Groebner bases relies on the same technique:

1. In the Groebner basis there is a univariate equation;
2. Solve it, and substitute found roots into other equations;
3. Go to 1.

WIP. For the implementation of symbolic system solving check out `roots` in `Symbolics.jl` !

## Integer Programming


Integer programming is the problem of solving linear equations where the solution must be in non-negative integers and should minimize a given "cost function".

Our strategy here is to convert the integer programming problem into a problem about polynomials, and then solve this polynomial problem using Groebner bases.

*The classic example problem is the following.* Say we have coins of 4 nominal values: pennies $P$, nickels $N$, dimes $D$, and quarters $Q$. We want to pick a collection that amounts to 117 using the least number of coins possible.

In other words, minimize $P + N + D + Q$ subject to $P, N, D, Q \ge 0$ and

$$
P + 5N + 10D + 25Q = 117
$$

The minimal integer solution is $(P, N, D, Q) = (2, 1, 1, 4)$, let's try to find it with Groebner bases.

First, we will represent each collection of coins by a polynomial $p^an^bd^cq^d$ in variables $p, n, d, q$ (e.g., 2 pennies with 5 dimes is $p^2d^5$).

We also know that $p^5$ is the same as $n$, $p^{10}$ is the same as $d$, and so on. The full set of constraints is

\[
F = \{p^5 - n, p^10 - d, p^25 - q\}
\]

The idea is to construct a more useful set of constraints using a Groebner basis

```julia:coins1
_, (p, n, d, q) = PolynomialRing(QQ, ["p","n","d","q"], ordering=:deglex)

F = [p^5 - n, p^10 - d, p^25 - q]   # initial constraints

G = groebner(F)   # more nice and useful constraints
```

\note{Notice we construct polynomials in `deglex` ordering, instead of the default `lex`.}

These new constraints express a useful set of replacement (rewrite) rules. E.g., the expression `d^3 - n*q` in the basis translates to: replace 3 dimes with a nickel and a quarter.

Now, we take an arbitrary solution (not necessarily minimal), say $p^{17}n^{10}d^5$, and compute the normal form w.r.t. $G$

```julia:coins2
normalform(G, p^17*n^10*d^5)
```

to obtain the minimial solution $(P, N, D, Q) = (2, 1, 1, 4)$.

## Graph Coloring

In graph theory, Graph coloring is a problem of assigning a color to each vertex of a graph in a way that no two neighboring vertices the same color.

```julia:graph0
using Graphs # hide
using GraphPlot # hide
g = Graph(4) # hide
add_edge!(g, 1, 2); # hide
add_edge!(g, 1, 3); # hide
add_edge!(g, 1, 4); # hide
add_edge!(g, 2, 3); # hide
add_edge!(g, 3, 4); # hide
```

```julia:graph1
# hIdeall
xs = [0.5, 1.0, 0.5, 0.0]
ys = [-sqrt(3) / 6, 0.0, -1.0, 0.0]
nodelabeldist = 1.5
nodelabel = collect(1:4)
draw(SVG(joinpath(@OUTPUT, "graph2.svg"), 16cm, 16cm), gplot(g, xs, ys, nodelabel=nodelabel, nodelabeldist=nodelabeldist));
```

\fig{graph2}

The common hard question is *the existence of a proper coloring with $k$ colors* for $k > 2$. In this section, we will show how the question can be tackled using the Groebner bases approach.

The approach is to

- Establish relation between *k-coloring* and *system of polynomial equations*
- Solve the system or prove unsolvable

There are two types of polynomials forming a typical graph coloring system.

First, for each vertex $j$ in a graph we assign variable $x_j$. To fix that each particular vertex $j$ has a color we construct *vertex polynomials* of form

\[
x_j^k - 1 = 0
\]

for each vertex $j$. Then one color out of $k$ is represented as one of the $k$-th roots of unity.

Secondly, we add *edge polynomials*

\[
\frac{x_i^k - x_j^k}{x_i - x_j}
\]

for each $i \rightarrow j$ in edges to ensure two neighboring vertices do not share the same color. Such polynomial disallows that colors  $x_i$ and $x_j$ for two neighbors $i$ and $j$ coincide. Finally, solutions of a system constructed this way correspond to proper k-colorings in a 1 to 1 relation.

For example, the coloring system for k=3 in the graph above must contain vertex polynomials

\[
\{ x_1^3 - 1,~ x_2^3 - 1,~ x_3^3 - 1,~ x_4^3 - 1 \}
\]

and a bunch of edge polynomials. Note that adding an edge polynomial $\frac{x_i^3 - x_j^3}{x_i - x_j}$ to a system is equivalent to adding $x_i^2 + x_ix_j + x_j$ to it.

Now consider the resulting coloring system for the graph from the picture

```julia:graph3
_, (x1, x2, x3, x4) = QQ["x1","x2","x3","x4"]

coloring_system = [
  x1^3 - 1, x2^3 - 1, x3^3 - 1, x4^3 - 1,
  x1^2 + x1*x2 + x2^2,
  x1^2 + x1*x3 + x3^2,
  x1^2 + x1*x4 + x4^2,
  x2^2 + x2*x3 + x3^2,
  x3^2 + x3*x4 + x4^2
]

groebner(coloring_system)
```

From the `x2 - x4` equation in the basis we understand 2nd and 4th vertices should be of the same color. It only remains to assign colors to the remaining vertices

```julia:graph4
# hIdeall
nodefillc = ["red", "blue", "green", "blue"]

xs = [0.5, 1.0, 0.5, 0.0]
ys = [-sqrt(3) / 6, 0.0, -1.0, 0.0]
nodelabeldist = 1.5
nodelabel = collect(1:4)
draw(SVG(joinpath(@OUTPUT, "graphcolored.svg"), 16cm, 16cm), gplot(g, xs, ys, nodelabel=nodelabel, nodelabeldist=nodelabeldist, nodefillc=nodefillc));
```

\fig{graphcolored}
