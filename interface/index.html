<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · Groebner.jl</title><meta name="title" content="Interface · Groebner.jl"/><meta property="og:title" content="Interface · Groebner.jl"/><meta property="twitter:title" content="Interface · Groebner.jl"/><meta name="description" content="Documentation for Groebner.jl."/><meta property="og:description" content="Documentation for Groebner.jl."/><meta property="twitter:description" content="Documentation for Groebner.jl."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-09PS33NY4L"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-09PS33NY4L', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Groebner.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Groebner.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Groebner.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Interface</a><ul class="internal"><li><a class="tocitem" href="#Main-functions"><span>Main functions</span></a></li><li><a class="tocitem" href="#Monomial-orderings"><span>Monomial orderings</span></a></li><li><a class="tocitem" href="#Learn-and-Apply"><span>Learn and Apply</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sumiya11/Groebner.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sumiya11/Groebner.jl/blob/master/docs/src/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h1><h2 id="Main-functions"><a class="docs-heading-anchor" href="#Main-functions">Main functions</a><a id="Main-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.groebner" href="#Groebner.groebner"><code>Groebner.groebner</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">groebner(polynomials; options...)</code></pre><p>Computes a Groebner basis of the ideal generated by <code>polynomials</code>.</p><p><strong>Arguments</strong></p><ul><li><code>polynomials</code>: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.</li></ul><p><strong>Returns</strong></p><ul><li><code>basis</code>: an array of polynomials, a Groebner basis.</li></ul><p><strong>Possible Options</strong></p><ul><li><code>reduced</code>: A bool, if the returned basis must be autoreduced and unique. Default is <code>true</code>.</li><li><code>ordering</code>: Specifies the monomial ordering. Available monomial orderings are: <ul><li><code>InputOrdering()</code> for inferring the ordering from the given <code>polynomials</code> (default), </li><li><code>Lex(args...)</code> for lexicographic, </li><li><code>DegLex(args...)</code> for degree lexicographic, </li><li><code>DegRevLex(args...)</code> for degree reverse lexicographic, </li><li><code>WeightedOrdering(args...)</code> for weighted ordering, </li><li><code>ProductOrdering(args...)</code> for block ordering, </li><li><code>MatrixOrdering(args...)</code> for matrix ordering.</li></ul>For details and examples see the corresponding documentation page.</li><li><code>certify</code>: A bool, whether to certify the obtained basis. When this option is   <code>false</code>, the algorithm is randomized and the result is correct with high   probability. When this option is <code>true</code>, the result is guaranteed to be   correct in case the ideal is homogeneous. Default is <code>false</code>. </li><li><code>linalg</code>: A symbol, linear algebra backend. Available options are: <ul><li><code>:auto</code> for the automatic choice (default),</li><li><code>:deterministic</code> for deterministic sparse linear algebra, </li><li><code>:randomized</code> for probabilistic sparse linear algebra.</li></ul></li><li><code>threaded</code>: The use of multi-threading. Available options are: <ul><li><code>:auto</code> for the automatic choice (default),</li><li><code>:no</code> never use multi-threading, </li><li><code>:yes</code> allow the use of multi-threading.</li></ul>Additionally, it is possible to set the environment variable   <code>GROEBNER_NO_THREADED</code> to <code>1</code> to disable all multi-threading in Groebner.jl.   In this case, the environment variable takes precedence over the <code>threaded</code>   option.</li><li><code>monoms</code>: Monomial representation used in the computations. Available options are: <ul><li><code>:auto</code> for the automatic choice (default), </li><li><code>:dense</code> for classic dense exponent vectors,</li><li><code>:packed</code> for packed representation. </li></ul></li><li><code>modular</code>: Modular computation algorithm. Only has effect when computing basis   over rational numbers. Available options are:<ul><li><code>:auto</code> for the automatic choice (default),</li><li><code>:classic_modular</code> for the classic multi-modular algorithm,</li><li><code>:learn_and_apply</code> for the learn &amp; apply algorithm.</li></ul></li><li><code>seed</code>: The seed for randomization. Default is <code>42</code>.</li><li><code>homogenize</code>: Controls the use of homogenization in the algorithm. Available options are:<ul><li><code>:auto</code>, for the automatic choice (default).</li><li><code>:yes</code>, always homogenize the input ideal,</li><li><code>:no</code>, never homogenize the input ideal,</li></ul></li></ul><p><strong>Example</strong></p><p>Using DynamicPolynomials.jl:</p><pre><code class="language- hljs">using Groebner, DynamicPolynomials
@polyvar x y
groebner([x*y^2 + x, y*x^2 + y])</code></pre><p>Using AbstractAlgebra.jl:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;]
groebner([x*y^2 + x, y*x^2 + y])</code></pre><p>Using Nemo.jl:</p><pre><code class="language- hljs">using Groebner, Nemo
R, (x, y) = GF(2^30+3)[&quot;x&quot;, &quot;y&quot;]
groebner([x*y^2 + x, y*x^2 + y])</code></pre><p>Or, say, in another monomial ordering:</p><pre><code class="language- hljs"># lex with y &gt; x
groebner([x*y^2 + x, y*x^2 + y], ordering=Lex(y, x))

# degree reverse lexicographic
groebner([x*y^2 + x, y*x^2 + y], ordering=DegRevLex())</code></pre><p><strong>Notes</strong></p><ul><li>The function is thread-safe.</li><li>For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over <code>GF(p)</code>, <code>Native.GF(p)</code>, and <code>QQ</code>.</li><li>The default algorithm is probabilistic (with <code>certify=false</code>). Results are   correct with high probability, however, no precise bound on the probability   is known.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L3-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.isgroebner" href="#Groebner.isgroebner"><code>Groebner.isgroebner</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isgroebner(polynomials; options...)</code></pre><p>Checks if <code>polynomials</code> forms a Groebner basis.</p><p><strong>Arguments</strong></p><ul><li><code>polynomials</code>: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl. </li></ul><p><strong>Returns</strong></p><ul><li><code>flag</code>: a bool, whether <code>polynomials</code> is a Groebner basis of the ideal generated by <code>polynomials</code>.</li></ul><p><strong>Possible Options</strong></p><ul><li><code>ordering</code>: Specifies the monomial ordering. Available monomial orderings are: <ul><li><code>InputOrdering()</code> for inferring the ordering from the given <code>polynomials</code> (default), </li><li><code>Lex()</code> for lexicographic, </li><li><code>DegLex()</code> for degree lexicographic, </li><li><code>DegRevLex()</code> for degree reverse lexicographic, </li><li><code>WeightedOrdering(weights)</code> for weighted ordering, </li><li><code>ProductOrdering(args...)</code> for block ordering, </li><li><code>MatrixOrdering(matrix)</code> for matrix ordering. </li></ul>For details and examples see the corresponding documentation page.</li><li><code>certify</code>: a bool, whether to use a deterministic algorithm. Default is <code>false</code>.</li><li><code>seed</code>: The seed for randomization. Default value is <code>42</code>.</li></ul><p><strong>Example</strong></p><p>Using <code>DynamicPolynomials</code>:</p><pre><code class="language- hljs">using Groebner, DynamicPolynomials
@polyvar x y;
isgroebner([x*y^2 + x, y*x^2 + y])</code></pre><p>Using <code>AbstractAlgebra</code>:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;]
isgroebner([x*y^2 + x, y*x^2 + y])</code></pre><p><strong>Notes</strong></p><ul><li>The function is thread-safe.</li><li>For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over <code>GF(p)</code>, <code>Native.GF(p)</code>, and <code>QQ</code>.</li><li>The default algorithm is probabilistic (with <code>certify=false</code>). Results are   correct with high probability, however, no precise bound on the probability   is known. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L448-L505">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.normalform" href="#Groebner.normalform"><code>Groebner.normalform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalform(basis, to_be_reduced; options...)</code></pre><p>Computes the normal form of polynomials <code>to_be_reduced</code> with respect to a Groebner basis <code>basis</code>.</p><p><strong>Arguments</strong></p><ul><li><code>basis</code>: an array of polynomials, a Groebner basis. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.</li><li><code>to_be_reduced</code>: either a single polynomial or an array of polynomials.   Supports polynomials from AbstractAlgebra.jl, Nemo.jl, and   DynamicPolynomials.jl.</li></ul><p><strong>Returns</strong></p><ul><li><code>reduced</code>: either a single polynomial or an array of polynomials, the normal forms.</li></ul><p><strong>Possible Options</strong></p><ul><li><code>check</code>: Check if <code>basis</code> forms a Groebner basis. Default is <code>true</code>.</li><li><code>ordering</code>: Specifies the monomial ordering. Available monomial orderings are: <ul><li><code>InputOrdering()</code> for inferring the ordering from the given <code>polynomials</code> (default), </li><li><code>Lex()</code> for lexicographic, </li><li><code>DegLex()</code> for degree lexicographic, </li><li><code>DegRevLex()</code> for degree reverse lexicographic, </li><li><code>WeightedOrdering(weights)</code> for weighted ordering, </li><li><code>ProductOrdering(args...)</code> for block ordering, </li><li><code>MatrixOrdering(matrix)</code> for matrix ordering. </li></ul>For details and examples see the corresponding documentation page.</li></ul><p><strong>Example</strong></p><p>Fining the normal form a single polynomial:</p><pre><code class="language- hljs">using Groebner, DynamicPolynomials
@polyvar x y;
normalform([y^2 + x, x^2 + y], x^2 + y^2 + 1)</code></pre><p>Or, reducing two polynomials at a time:</p><pre><code class="language- hljs">using Groebner, DynamicPolynomials
@polyvar x y;
normalform([y^2 + x, x^2 + y], [x^2 + y^2 + 1, x^10*y^10])</code></pre><p><strong>Notes</strong></p><ul><li>The function is thread-safe.</li><li>For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over <code>GF(p)</code>, <code>Native.GF(p)</code>, and <code>QQ</code>.</li><li>The default algorithm is probabilistic (with <code>certify=false</code>). Results are   correct with high probability, however, no precise bound on the probability   is known.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L520-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.leading_ideal" href="#Groebner.leading_ideal"><code>Groebner.leading_ideal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leading_ideal(polynomials; options...)</code></pre><p>Returns generators of the ideal of the leading terms.</p><p>If the input is not a Groebner basis, computes a Groebner basis.</p><p><strong>Arguments</strong></p><ul><li><code>polynomials</code>: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.</li></ul><p><strong>Returns</strong></p><ul><li><code>basis</code>: the basis of the ideal of the leading terms.</li></ul><p><strong>Possible Options</strong></p><ul><li><code>ordering</code>: Specifies the monomial ordering. Available monomial orderings are:<ul><li><code>InputOrdering()</code> for inferring the ordering from the given <code>polynomials</code> (default),</li><li><code>Lex()</code> for lexicographic,</li><li><code>DegLex()</code> for degree lexicographic,</li><li><code>DegRevLex()</code> for degree reverse lexicographic,</li><li><code>WeightedOrdering(weights)</code> for weighted ordering,</li><li><code>ProductOrdering(args...)</code> for block ordering,</li><li><code>MatrixOrdering(matrix)</code> for matrix ordering.</li></ul>For details and examples see the corresponding documentation page.</li></ul><p><strong>Example</strong></p><p>Using AbstractAlgebra.jl:</p><pre><code class="language- hljs">using Groebner, Nemo
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;]
leading_ideal([x*y^2 + x, y*x^2 + y])</code></pre><p><strong>Notes</strong></p><ul><li>The function is thread-safe.</li><li>For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over <code>GF(p)</code>, <code>Native.GF(p)</code>, and <code>QQ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L650-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.dimension" href="#Groebner.dimension"><code>Groebner.dimension</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimension(polynomials; options...)</code></pre><p>Computes the (Krull) dimension of the ideal generated by <code>polynomials</code>.</p><p>If input is not a Groebner basis, computes a Groebner basis.</p><p><strong>Arguments</strong></p><ul><li><code>polynomials</code>: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.</li></ul><p><strong>Returns</strong></p><ul><li><code>dimension</code>: an integer, the dimension.</li></ul><p><strong>Example</strong></p><p>Using AbstractAlgebra.jl:</p><pre><code class="language- hljs">using Groebner, Nemo
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;]
dimension([x*y^2 + x, y*x^2 + y])</code></pre><p><strong>Notes</strong></p><ul><li>The function is thread-safe.</li><li>For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over <code>GF(p)</code>, <code>Native.GF(p)</code>, and <code>QQ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L753-L784">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.quotient_basis" href="#Groebner.quotient_basis"><code>Groebner.quotient_basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quotient_basis(polynomials; options...)</code></pre><p>Returns a monomial basis of the quotient algebra of a zero-dimensional ideal.</p><p>If the input is not a Groebner basis, computes a Groebner basis. If the input is not a zero-dimensional ideal, an error is raised.</p><p><strong>Arguments</strong></p><ul><li><code>polynomials</code>: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.</li></ul><p><strong>Returns</strong></p><ul><li><code>basis</code>: an array of monomials, a quotient basis.</li></ul><p><strong>Possible Options</strong></p><ul><li><code>ordering</code>: Specifies the monomial ordering. Available monomial orderings are:<ul><li><code>InputOrdering()</code> for inferring the ordering from the given <code>polynomials</code> (default),</li><li><code>Lex()</code> for lexicographic,</li><li><code>DegLex()</code> for degree lexicographic,</li><li><code>DegRevLex()</code> for degree reverse lexicographic,</li><li><code>WeightedOrdering(weights)</code> for weighted ordering,</li><li><code>ProductOrdering(args...)</code> for block ordering,</li><li><code>MatrixOrdering(matrix)</code> for matrix ordering.</li></ul>For details and examples see the corresponding documentation page.</li></ul><p><strong>Example</strong></p><p>Using AbstractAlgebra.jl:</p><pre><code class="language- hljs">using Groebner, Nemo
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;]
quotient_basis([x*y^2 + x, y*x^2 + y])</code></pre><p><strong>Notes</strong></p><ul><li>The function is thread-safe.</li><li>For AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over <code>GF(p)</code>, <code>Native.GF(p)</code>, and <code>QQ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L701-L746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.groebner_with_change_matrix" href="#Groebner.groebner_with_change_matrix"><code>Groebner.groebner_with_change_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">groebner_with_change_matrix(polynomials; options...)</code></pre><p>Computes a Groebner basis of the ideal generated by <code>polynomials</code> and emits a change matrix, that is, a map from the original generators to basis elements.</p><p><strong>Arguments</strong></p><ul><li><code>polynomials</code>: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl. For   AbstractAlgebra.jl and Nemo.jl, coefficients of polynomials must belong to   <code>GF(p)</code>, <code>Native.GF(p)</code>, or <code>QQ</code>. </li></ul><p><strong>Returns</strong></p><p>Returns a tuple (<code>basis</code>, <code>matrix</code>).</p><ul><li><code>basis</code>: an array of polynomials, a Groebner basis.</li><li><code>matrix</code>: a matrix, so that <code>matrix * polynomials == basis</code>.</li></ul><p><strong>Possible Options</strong></p><p>Same as for <code>groebner</code>.</p><p><strong>Example</strong></p><p>Using AbstractAlgebra.jl:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;]
f = [x*y^2 + x, y*x^2 + y]

g, m = groebner_with_change_matrix(f, ordering=DegRevLex())

@assert isgroebner(g, ordering=DegRevLex())
@assert m * f == g</code></pre><p><strong>Notes</strong></p><ul><li>Only <code>DegRevLex</code> ordering is supported.</li><li>The function is thread-safe.</li><li>The default algorithm is probabilistic (with <code>certify=false</code>). Results are   correct with high probability, however, no precise bound on the probability   is known.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L161-L207">source</a></section></article><h2 id="Monomial-orderings"><a class="docs-heading-anchor" href="#Monomial-orderings">Monomial orderings</a><a id="Monomial-orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Monomial-orderings" title="Permalink"></a></h2><div class="admonition is-info" id="Note-5d4ec6d729399a1f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5d4ec6d729399a1f" title="Permalink"></a></header><div class="admonition-body"><p>Some frontends, for example, AbstractAlgebra.jl, may not support weighted/product/matrix orderings from Groebner.jl. In such cases, the basis is computed in the ordering requested by user, but the terms of polynomials in the output are ordered w.r.t. some other ordering that is supported by the frontend.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.Lex" href="#Groebner.Lex"><code>Groebner.Lex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lex()
Lex(variables)
Lex(variables...)</code></pre><p>Lexicographical monomial ordering.</p><p>We use the definition from Chapter 1, Computational Commutative Algebra 1, by Martin Kreuzer, Lorenzo Robbiano. DOI: https://doi.org/10.1007/978-3-540-70628-1.</p><p><em>Dura Lex, sed Lex.</em></p><p><strong>Example</strong></p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;];

# Lexicographical ordering with x &gt; y
groebner([x*y + x, x + y^2], ordering=Lex())

# Lexicographical ordering with y &gt; x
groebner([x*y + x, x + y^2], ordering=Lex([y, x]))

# Lexicographical ordering with x &gt; y
# Both syntax are allowed -- Lex([...]) and Lex(...)
groebner([x*y + x, x + y^2], ordering=Lex(x, y))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/monomials/orderings.jl#L31-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.DegLex" href="#Groebner.DegLex"><code>Groebner.DegLex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DegLex()
DegLex(variables)
DegLex(variables...)</code></pre><p>Degree lexicographical monomial ordering.</p><p>We use the definition from Chapter 1, Computational Commutative Algebra 1, by Martin Kreuzer, Lorenzo Robbiano. DOI: https://doi.org/10.1007/978-3-540-70628-1.</p><p><strong>Example</strong></p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;];

# Degree lexicographical ordering with x &gt; y
groebner([x*y + x, x + y^2], ordering=DegLex())

# Degree lexicographical ordering with y &gt; x
groebner([x*y + x, x + y^2], ordering=DegLex([y, x]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/monomials/orderings.jl#L80-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.DegRevLex" href="#Groebner.DegRevLex"><code>Groebner.DegRevLex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DegRevLex()
DegRevLex(variables)
DegRevLex(variables...)</code></pre><p>Degree reverse lexicographical monomial ordering.</p><p>We use the definition from Chapter 1, Computational Commutative Algebra 1, by Martin Kreuzer, Lorenzo Robbiano. DOI: https://doi.org/10.1007/978-3-540-70628-1.</p><p><strong>Example</strong></p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;];

# Degree reverse lexicographical ordering with x &gt; y
groebner([x*y + x, x + y^2], ordering=DegRevLex())

# Degree reverse lexicographical ordering with y &gt; x
groebner([x*y + x, x + y^2], ordering=DegRevLex(y, x))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/monomials/orderings.jl#L116-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.InputOrdering" href="#Groebner.InputOrdering"><code>Groebner.InputOrdering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InputOrdering()</code></pre><p>Preserves the monomial ordering defined on the input polynomials.</p><p>This is the default value for the <code>ordering</code> keyword argument.</p><p><strong>Example</strong></p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;]

# Uses the ordering `InputOrdering`, which, in this case, 
# defaults to the lexicographical ordering with x &gt; y
groebner([x*y + x, x + y^2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/monomials/orderings.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.WeightedOrdering" href="#Groebner.WeightedOrdering"><code>Groebner.WeightedOrdering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedOrdering(weights)</code></pre><p>Weighted monomial ordering.</p><p>Only positive weights are supported.</p><p><strong>Example</strong></p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = QQ[&quot;x&quot;, &quot;y&quot;];

# x has weight 3, y has weight 1
ord = WeightedOrdering(x =&gt; 3, y =&gt; 1)
groebner([x*y + x, x + y^2], ordering=ord)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/monomials/orderings.jl#L152-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.ProductOrdering" href="#Groebner.ProductOrdering"><code>Groebner.ProductOrdering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProductOrdering(ord1, ord2)</code></pre><p>Product monomial ordering. Compares by <code>ord1</code>, breaks ties by <code>ord2</code>.</p><p>Can also be constructed with <code>*</code>.</p><p><strong>Example</strong></p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y, z, w) = QQ[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;w&quot;];

# Ordering with x, y &gt; w, z
ord = ProductOrdering(DegRevLex(x, y), DegRevLex(w, z))
groebner([x*y + w, y*z - w], ordering=ord)</code></pre><p>It is possible to use the <code>*</code> operator:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y, z, t) = QQ[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;t&quot;];

ord1 = Lex(t)
ord2 = DegRevLex(x, y, z)
# t &gt;&gt; x, y, z
ord = ord1 * ord2
groebner([x*y*z + z, t * z - 1], ordering=ord)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/monomials/orderings.jl#L191-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.MatrixOrdering" href="#Groebner.MatrixOrdering"><code>Groebner.MatrixOrdering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixOrdering(matrix)
MatrixOrdering(Vector{Vector})</code></pre><p>Matrix monomial ordering. </p><p><strong>Example</strong></p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y, z, w) = QQ[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;w&quot;];

# the number of columns equal to the number of variables
ord = MatrixOrdering(
    [x,y,z,w],
    [
    1 0  0  2;
    0 0  1  2;
    0 1  1  1;
    ])
groebner([x*y + w, y*z - w], ordering=ord)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/monomials/orderings.jl#L250-L272">source</a></section></article><h2 id="Learn-and-Apply"><a class="docs-heading-anchor" href="#Learn-and-Apply">Learn and Apply</a><a id="Learn-and-Apply-1"></a><a class="docs-heading-anchor-permalink" href="#Learn-and-Apply" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.groebner_learn" href="#Groebner.groebner_learn"><code>Groebner.groebner_learn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">groebner_learn(polynomials; options...)</code></pre><p>Computes a Groebner basis of the ideal generated by <code>polynomials</code> and emits a trace.</p><p>The trace can be used to speed up the computation of Groebner bases of specializations of the same ideal as the one <code>groebner_learn</code> had been applied to.</p><p>See also <code>groebner_apply!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>polynomials</code>: an array of polynomials. Must be polynomials from AbstractAlgebra.jl or Nemo.jl over <code>GF(p)</code> or <code>Native.GF(p)</code>.</li></ul><p><strong>Returns</strong></p><p>Returns a tuple (<code>trace</code>, <code>basis</code>).</p><ul><li><code>trace</code>: an object, a trace. Can be used in <code>groebner_apply!</code>.</li><li><code>basis</code>: an array of polynomials, a Groebner basis.</li></ul><p><strong>Possible Options</strong></p><p>Same as for <code>groebner</code>.</p><p><strong>Example</strong></p><p>Using <code>groebner_learn</code> and <code>groebner_apply!</code> over the same ground field:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = GF(2^31-1)[&quot;x&quot;, &quot;y&quot;]

# Learn
trace, gb_1 = groebner_learn([x*y^2 + x, y*x^2 + y])

# Apply (same support, different coefficients)
flag, gb_2 = groebner_apply!(trace, [2x*y^2 + 3x, 4y*x^2 + 5y])

@assert flag</code></pre><p>Using <code>groebner_learn</code> and <code>groebner_apply!</code> over different ground fields:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = GF(2^31-1)[&quot;x&quot;, &quot;y&quot;]

# Learn
trace, gb_1 = groebner_learn([x*y^2 + x, y*x^2 + y], ordering=DegRevLex())

# Create a ring with a different modulo
R2, (x2, y2) = GF(2^30+3)[&quot;x&quot;, &quot;y&quot;]

# Apply (different modulo)
flag, gb_2 = groebner_apply!(
    trace, 
    [2x2*y2^2 + 3x2, 4y2*x2^2 + 5y2], 
    ordering=DegRevLex()
)

@assert flag
@assert gb_2 == groebner([2x2*y2^2 + 3x2, 4y2*x2^2 + 5y2], ordering=DegRevLex())</code></pre><p>Using <code>groebner_apply!</code> in batches:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra
R, (x, y) = polynomial_ring(GF(2^31-1), [&quot;x&quot;, &quot;y&quot;], internal_ordering=:degrevlex)

# Learn
trace, gb_1 = groebner_learn([x*y^2 + x, y*x^2 + y])

# Create rings with some other moduli
R2, (x2, y2) = polynomial_ring(GF(2^30+3), [&quot;x&quot;, &quot;y&quot;], internal_ordering=:degrevlex)
R3, (x3, y3) = polynomial_ring(GF(2^27+29), [&quot;x&quot;, &quot;y&quot;], internal_ordering=:degrevlex)

# Two specializations of the same ideal
batch = ([2x2*y2^2 + 3x2, 4y2*x2^2 + 5y2], [4x3*y3^2 + 4x3, 5y3*x3^2 + 7y3])

# Apply for two sets of polynomials at once
flag, (gb_2, gb_3) = groebner_apply!(trace, batch)

@assert flag
@assert (gb_2, gb_3) == map(groebner, batch)</code></pre><p>Perhaps, in a more involved example, we will compute Groebner bases of the Katsura-9 system:</p><pre><code class="language- hljs">using Groebner, AbstractAlgebra, BenchmarkTools

# Create the system
kat = Groebner.Examples.katsuran(9, k=ZZ, internal_ordering=:degrevlex)

# Reduce the coefficients modulo 5 different primes
kat_0 = map(f -&gt; map_coefficients(c -&gt; GF(2^30 + 3)(c), f), kat)
kat_1 = map(f -&gt; map_coefficients(c -&gt; GF(2^30 + 7)(c), f), kat)
kat_2 = map(f -&gt; map_coefficients(c -&gt; GF(2^30 + 9)(c), f), kat)
kat_3 = map(f -&gt; map_coefficients(c -&gt; GF(2^30 + 15)(c), f), kat)
kat_4 = map(f -&gt; map_coefficients(c -&gt; GF(2^30 + 19)(c), f), kat)

# Learn the trace
trace, gb_0 = groebner_learn(kat_0);

# Compare the performance of applying with 1 input and with 4 different inputs:

# Apply for one system
@btime groebner_apply!($trace, $kat_1);
#  46.824 ms (19260 allocations: 24.48 MiB)

# Apply for a batch of four systems
@btime groebner_apply!($trace, $(kat_1, kat_2, kat_3, kat_4));
#  72.813 ms (23722 allocations: 59.44 MiB)</code></pre><p>Observe the better amortized performance of the composite <code>groebner_apply!</code>.</p><p><strong>Notes</strong></p><ul><li>The function is thread-safe.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L214-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Groebner.groebner_apply!" href="#Groebner.groebner_apply!"><code>Groebner.groebner_apply!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">groebner_apply!(trace, polynomials; options...)
groebner_apply!(trace, batch::NTuple{N, Vector}; options...)</code></pre><p>Computes a Groebner basis of the ideal generated by <code>polynomials</code> following the given <code>trace</code>. </p><p>See also <code>groebner_learn</code>.</p><p><strong>Arguments</strong></p><ul><li><code>trace</code>: a trace produced by <code>groebner_learn</code>.</li><li><code>polynomials</code>: an array of polynomials. Must be polynomials from   AbstractAlgebra.jl or Nemo.jl over <code>GF(p)</code> or <code>Nemo.GF(p)</code>. It is possible   to supply a tuple of <code>N</code> arrays of polynomials to compute <code>N</code> Groebner bases   simultaneously. This could be more efficient overall than computing them in   separate.</li></ul><p><strong>Returns</strong></p><p>Returns a tuple (<code>success</code>, <code>basis</code>).</p><ul><li><code>success</code>: a bool, whether the call succeeded.</li><li><code>basis</code>: an array of polynomials, a Groebner basis.</li></ul><p><strong>Possible Options</strong></p><p>The <code>groebner_apply!</code> function automatically inherits most parameters from the given <code>trace</code>.</p><p><strong>Example</strong></p><p>For examples, see the documentation of <code>groebner_learn</code>.</p><p><strong>Notes</strong></p><ul><li><p>In general, <code>success</code> may be a false positive. The probability of a false positive is considered to be low enough in some practical applications.</p></li><li><p>This function is <strong>not</strong> thread-safe since it mutates <code>trace</code>.</p></li><li><p>This function is <strong>not</strong> safe against program interruptions. For example,   pressing <code>Ctrl + C</code> while <code>groebner_apply!(trace, ...)</code> is running may leave   <code>trace</code> corrupted.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sumiya11/Groebner.jl/blob/928ed7328a972e86c2615d1c6d5edb29227ea2eb/src/interface.jl#L355-L399">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 7 August 2025 14:12">Thursday 7 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
