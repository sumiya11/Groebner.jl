var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/#Main-functions","page":"Interface","title":"Main functions","text":"","category":"section"},{"location":"interface/#Monomial-orderings","page":"Interface","title":"Monomial orderings","text":"note: Note\nSome frontends, for example, AbstractAlgebra.jl, may not support weighted/product/matrix orderings from Groebner.jl. In such cases, the basis is computed in the ordering requested by user, but the terms of polynomials in the output are ordered w.r.t. some other ordering that is supported by the frontend.","category":"section"},{"location":"interface/#Learn-and-Apply","page":"Interface","title":"Learn and Apply","text":"","category":"section"},{"location":"interface/#Groebner.groebner","page":"Interface","title":"Groebner.groebner","text":"groebner(polynomials; options...)\n\nComputes a Groebner basis of the ideal generated by polynomials.\n\nArguments\n\npolynomials: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.\n\nReturns\n\nbasis: an array of polynomials, a Groebner basis.\n\nPossible Options\n\nreduced: A bool, if the returned basis must be autoreduced and unique. Default is true.\nordering: Specifies the monomial ordering. Available monomial orderings are: \nInputOrdering() for inferring the ordering from the given polynomials (default), \nLex(args...) for lexicographic, \nDegLex(args...) for degree lexicographic, \nDegRevLex(args...) for degree reverse lexicographic, \nWeightedOrdering(args...) for weighted ordering, \nProductOrdering(args...) for block ordering, \nMatrixOrdering(args...) for matrix ordering.\nFor details and examples see the corresponding documentation page.\ncertify: A bool, whether to certify the obtained basis. When this option is   false, the algorithm is randomized and the result is correct with high   probability. When this option is true, the result is guaranteed to be   correct in case the ideal is homogeneous. Default is false. \nlinalg: A symbol, linear algebra backend. Available options are: \n:auto for the automatic choice (default),\n:deterministic for deterministic sparse linear algebra, \n:randomized for probabilistic sparse linear algebra.\ntasks: The number of tasks used in multi-threading. Available options are:\n:auto for the automatic choice (default). Generally corresponds to Threads.nthreads(), but may be smaller.\nN, an integer, the number of tasks. Providing tasks=N ensures that at most N tasks run in parallel (excluding the main program).\nSee also Groebner.threading_enabled.\nmonoms: Monomial representation used in the computations. Available options are: \n:auto for the automatic choice (default), \n:dense for classic dense exponent vectors,\n:packed for packed representation. \nmodular: Modular computation algorithm. Only has effect when computing basis   over rational numbers. Available options are:\n:auto for the automatic choice (default),\n:classic_modular for the classic multi-modular algorithm,\n:learn_and_apply for the learn & apply algorithm.\nseed: The seed for randomization. Default is 42.\nhomogenize: Controls the use of homogenization in the algorithm. Available options are:\n:auto, for the automatic choice (default).\n:yes, always homogenize the input ideal,\n:no, never homogenize the input ideal,\n\nExample\n\nUsing DynamicPolynomials.jl:\n\nusing Groebner, DynamicPolynomials\n@polyvar x y\ngroebner([x*y^2 + x, y*x^2 + y])\n\nUsing AbstractAlgebra.jl:\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"]\ngroebner([x*y^2 + x, y*x^2 + y])\n\nUsing Nemo.jl:\n\nusing Groebner, Nemo\nR, (x, y) = GF(2^30+3)[\"x\", \"y\"]\ngroebner([x*y^2 + x, y*x^2 + y])\n\nOr, say, in another monomial ordering:\n\n# lex with y > x\ngroebner([x*y^2 + x, y*x^2 + y], ordering=Lex(y, x))\n\n# degree reverse lexicographic\ngroebner([x*y^2 + x, y*x^2 + y], ordering=DegRevLex())\n\nNotes\n\nThe function is thread-safe.\nFor AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over GF(p), Native.GF(p), and QQ.\nThe default algorithm is probabilistic (with certify=false). Results are   correct with high probability, however, no precise bound on the probability   is known.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.isgroebner","page":"Interface","title":"Groebner.isgroebner","text":"isgroebner(polynomials; options...)\n\nChecks if polynomials forms a Groebner basis.\n\nArguments\n\npolynomials: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl. \n\nReturns\n\nflag: a bool, whether polynomials is a Groebner basis of the ideal generated by polynomials.\n\nPossible Options\n\nordering: Specifies the monomial ordering. Available monomial orderings are: \nInputOrdering() for inferring the ordering from the given polynomials (default), \nLex() for lexicographic, \nDegLex() for degree lexicographic, \nDegRevLex() for degree reverse lexicographic, \nWeightedOrdering(weights) for weighted ordering, \nProductOrdering(args...) for block ordering, \nMatrixOrdering(matrix) for matrix ordering. \nFor details and examples see the corresponding documentation page.\ncertify: a bool, whether to use a deterministic algorithm. Default is false.\nseed: The seed for randomization. Default value is 42.\n\nExample\n\nUsing DynamicPolynomials:\n\nusing Groebner, DynamicPolynomials\n@polyvar x y;\nisgroebner([x*y^2 + x, y*x^2 + y])\n\nUsing AbstractAlgebra:\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"]\nisgroebner([x*y^2 + x, y*x^2 + y])\n\nNotes\n\nThe function is thread-safe.\nFor AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over GF(p), Native.GF(p), and QQ.\nThe default algorithm is probabilistic (with certify=false). Results are   correct with high probability, however, no precise bound on the probability   is known. \n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.normalform","page":"Interface","title":"Groebner.normalform","text":"normalform(basis, to_be_reduced; options...)\n\nComputes the normal form of polynomials to_be_reduced with respect to a Groebner basis basis.\n\nArguments\n\nbasis: an array of polynomials, a Groebner basis. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.\nto_be_reduced: either a single polynomial or an array of polynomials.   Supports polynomials from AbstractAlgebra.jl, Nemo.jl, and   DynamicPolynomials.jl.\n\nReturns\n\nreduced: either a single polynomial or an array of polynomials, the normal forms.\n\nPossible Options\n\ncheck: Check if basis forms a Groebner basis. Default is true.\nordering: Specifies the monomial ordering. Available monomial orderings are: \nInputOrdering() for inferring the ordering from the given polynomials (default), \nLex() for lexicographic, \nDegLex() for degree lexicographic, \nDegRevLex() for degree reverse lexicographic, \nWeightedOrdering(weights) for weighted ordering, \nProductOrdering(args...) for block ordering, \nMatrixOrdering(matrix) for matrix ordering. \nFor details and examples see the corresponding documentation page.\n\nExample\n\nFining the normal form a single polynomial:\n\nusing Groebner, DynamicPolynomials\n@polyvar x y;\nnormalform([y^2 + x, x^2 + y], x^2 + y^2 + 1)\n\nOr, reducing two polynomials at a time:\n\nusing Groebner, DynamicPolynomials\n@polyvar x y;\nnormalform([y^2 + x, x^2 + y], [x^2 + y^2 + 1, x^10*y^10])\n\nNotes\n\nThe function is thread-safe.\nFor AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over GF(p), Native.GF(p), and QQ.\nThe default algorithm is probabilistic (with certify=false). Results are   correct with high probability, however, no precise bound on the probability   is known.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.leading_ideal","page":"Interface","title":"Groebner.leading_ideal","text":"leading_ideal(polynomials; options...)\n\nReturns generators of the ideal of the leading terms.\n\nIf the input is not a Groebner basis, computes a Groebner basis.\n\nArguments\n\npolynomials: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.\n\nReturns\n\nbasis: the basis of the ideal of the leading terms.\n\nPossible Options\n\nordering: Specifies the monomial ordering. Available monomial orderings are:\nInputOrdering() for inferring the ordering from the given polynomials (default),\nLex() for lexicographic,\nDegLex() for degree lexicographic,\nDegRevLex() for degree reverse lexicographic,\nWeightedOrdering(weights) for weighted ordering,\nProductOrdering(args...) for block ordering,\nMatrixOrdering(matrix) for matrix ordering.\nFor details and examples see the corresponding documentation page.\n\nExample\n\nUsing AbstractAlgebra.jl:\n\nusing Groebner, Nemo\nR, (x, y) = QQ[\"x\", \"y\"]\nleading_ideal([x*y^2 + x, y*x^2 + y])\n\nNotes\n\nThe function is thread-safe.\nFor AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over GF(p), Native.GF(p), and QQ.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.dimension","page":"Interface","title":"Groebner.dimension","text":"dimension(polynomials; options...)\n\nComputes the (Krull) dimension of the ideal generated by polynomials.\n\nIf input is not a Groebner basis, computes a Groebner basis.\n\nArguments\n\npolynomials: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.\n\nReturns\n\ndimension: an integer, the dimension.\n\nExample\n\nUsing AbstractAlgebra.jl:\n\nusing Groebner, Nemo\nR, (x, y) = QQ[\"x\", \"y\"]\ndimension([x*y^2 + x, y*x^2 + y])\n\nNotes\n\nThe function is thread-safe.\nFor AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over GF(p), Native.GF(p), and QQ.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.quotient_basis","page":"Interface","title":"Groebner.quotient_basis","text":"quotient_basis(polynomials; options...)\n\nReturns a monomial basis of the quotient algebra of a zero-dimensional ideal.\n\nIf the input is not a Groebner basis, computes a Groebner basis. If the input is not a zero-dimensional ideal, an error is raised.\n\nArguments\n\npolynomials: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl.\n\nReturns\n\nbasis: an array of monomials, a quotient basis.\n\nPossible Options\n\nordering: Specifies the monomial ordering. Available monomial orderings are:\nInputOrdering() for inferring the ordering from the given polynomials (default),\nLex() for lexicographic,\nDegLex() for degree lexicographic,\nDegRevLex() for degree reverse lexicographic,\nWeightedOrdering(weights) for weighted ordering,\nProductOrdering(args...) for block ordering,\nMatrixOrdering(matrix) for matrix ordering.\nFor details and examples see the corresponding documentation page.\n\nExample\n\nUsing AbstractAlgebra.jl:\n\nusing Groebner, Nemo\nR, (x, y) = QQ[\"x\", \"y\"]\nquotient_basis([x*y^2 + x, y*x^2 + y])\n\nNotes\n\nThe function is thread-safe.\nFor AbstractAlgebra.jl and Nemo.jl, the function is most efficient for   polynomials over GF(p), Native.GF(p), and QQ.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.groebner_with_change_matrix","page":"Interface","title":"Groebner.groebner_with_change_matrix","text":"groebner_with_change_matrix(polynomials; options...)\n\nComputes a Groebner basis of the ideal generated by polynomials and emits a change matrix, that is, a map from the original generators to basis elements.\n\nArguments\n\npolynomials: an array of polynomials. Supports polynomials from   AbstractAlgebra.jl, Nemo.jl, and DynamicPolynomials.jl. For   AbstractAlgebra.jl and Nemo.jl, coefficients of polynomials must belong to   GF(p), Native.GF(p), or QQ. \n\nReturns\n\nReturns a tuple (basis, matrix).\n\nbasis: an array of polynomials, a Groebner basis.\nmatrix: a matrix, so that matrix * polynomials == basis.\n\nPossible Options\n\nSame as for groebner.\n\nExample\n\nUsing AbstractAlgebra.jl:\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"]\nf = [x*y^2 + x, y*x^2 + y]\n\ng, m = groebner_with_change_matrix(f, ordering=DegRevLex())\n\n@assert isgroebner(g, ordering=DegRevLex())\n@assert m * f == g\n\nNotes\n\nOnly DegRevLex ordering is supported.\nThe function is thread-safe.\nThe default algorithm is probabilistic (with certify=false). Results are   correct with high probability, however, no precise bound on the probability   is known.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.Lex","page":"Interface","title":"Groebner.Lex","text":"Lex()\nLex(variables)\nLex(variables...)\n\nLexicographical monomial ordering.\n\nWe use the definition from Chapter 1, Computational Commutative Algebra 1, by Martin Kreuzer, Lorenzo Robbiano. DOI: https://doi.org/10.1007/978-3-540-70628-1.\n\nDura Lex, sed Lex.\n\nExample\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"];\n\n# Lexicographical ordering with x > y\ngroebner([x*y + x, x + y^2], ordering=Lex())\n\n# Lexicographical ordering with y > x\ngroebner([x*y + x, x + y^2], ordering=Lex([y, x]))\n\n# Lexicographical ordering with x > y\n# Both syntax are allowed -- Lex([...]) and Lex(...)\ngroebner([x*y + x, x + y^2], ordering=Lex(x, y))\n\n\n\n\n\n","category":"type"},{"location":"interface/#Groebner.DegLex","page":"Interface","title":"Groebner.DegLex","text":"DegLex()\nDegLex(variables)\nDegLex(variables...)\n\nDegree lexicographical monomial ordering.\n\nWe use the definition from Chapter 1, Computational Commutative Algebra 1, by Martin Kreuzer, Lorenzo Robbiano. DOI: https://doi.org/10.1007/978-3-540-70628-1.\n\nExample\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"];\n\n# Degree lexicographical ordering with x > y\ngroebner([x*y + x, x + y^2], ordering=DegLex())\n\n# Degree lexicographical ordering with y > x\ngroebner([x*y + x, x + y^2], ordering=DegLex([y, x]))\n\n\n\n\n\n","category":"type"},{"location":"interface/#Groebner.DegRevLex","page":"Interface","title":"Groebner.DegRevLex","text":"DegRevLex()\nDegRevLex(variables)\nDegRevLex(variables...)\n\nDegree reverse lexicographical monomial ordering.\n\nWe use the definition from Chapter 1, Computational Commutative Algebra 1, by Martin Kreuzer, Lorenzo Robbiano. DOI: https://doi.org/10.1007/978-3-540-70628-1.\n\nExample\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"];\n\n# Degree reverse lexicographical ordering with x > y\ngroebner([x*y + x, x + y^2], ordering=DegRevLex())\n\n# Degree reverse lexicographical ordering with y > x\ngroebner([x*y + x, x + y^2], ordering=DegRevLex(y, x))\n\n\n\n\n\n","category":"type"},{"location":"interface/#Groebner.InputOrdering","page":"Interface","title":"Groebner.InputOrdering","text":"InputOrdering()\n\nPreserves the monomial ordering defined on the input polynomials.\n\nThis is the default value for the ordering keyword argument.\n\nExample\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"]\n\n# Uses the ordering `InputOrdering`, which, in this case, \n# defaults to the lexicographical ordering with x > y\ngroebner([x*y + x, x + y^2])\n\n\n\n\n\n","category":"type"},{"location":"interface/#Groebner.WeightedOrdering","page":"Interface","title":"Groebner.WeightedOrdering","text":"WeightedOrdering(weights)\n\nWeighted monomial ordering.\n\nOnly positive weights are supported.\n\nExample\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = QQ[\"x\", \"y\"];\n\n# x has weight 3, y has weight 1\nord = WeightedOrdering(x => 3, y => 1)\ngroebner([x*y + x, x + y^2], ordering=ord)\n\n\n\n\n\n","category":"type"},{"location":"interface/#Groebner.ProductOrdering","page":"Interface","title":"Groebner.ProductOrdering","text":"ProductOrdering(ord1, ord2)\n\nProduct monomial ordering. Compares by ord1, breaks ties by ord2.\n\nCan also be constructed with *.\n\nExample\n\nusing Groebner, AbstractAlgebra\nR, (x, y, z, w) = QQ[\"x\", \"y\", \"z\", \"w\"];\n\n# Ordering with x, y > w, z\nord = ProductOrdering(DegRevLex(x, y), DegRevLex(w, z))\ngroebner([x*y + w, y*z - w], ordering=ord)\n\nIt is possible to use the * operator:\n\nusing Groebner, AbstractAlgebra\nR, (x, y, z, t) = QQ[\"x\", \"y\", \"z\", \"t\"];\n\nord1 = Lex(t)\nord2 = DegRevLex(x, y, z)\n# t >> x, y, z\nord = ord1 * ord2\ngroebner([x*y*z + z, t * z - 1], ordering=ord)\n\n\n\n\n\n","category":"type"},{"location":"interface/#Groebner.MatrixOrdering","page":"Interface","title":"Groebner.MatrixOrdering","text":"MatrixOrdering(matrix)\nMatrixOrdering(Vector{Vector})\n\nMatrix monomial ordering. \n\nExample\n\nusing Groebner, AbstractAlgebra\nR, (x, y, z, w) = QQ[\"x\", \"y\", \"z\", \"w\"];\n\n# the number of columns equal to the number of variables\nord = MatrixOrdering(\n    [x,y,z,w],\n    [\n    1 0  0  2;\n    0 0  1  2;\n    0 1  1  1;\n    ])\ngroebner([x*y + w, y*z - w], ordering=ord)\n\n\n\n\n\n","category":"type"},{"location":"interface/#Groebner.groebner_learn","page":"Interface","title":"Groebner.groebner_learn","text":"groebner_learn(polynomials; options...)\n\nComputes a Groebner basis of the ideal generated by polynomials and emits a trace.\n\nThe trace can be used to speed up the computation of Groebner bases of specializations of the same ideal as the one groebner_learn had been applied to.\n\nSee also groebner_apply!.\n\nArguments\n\npolynomials: an array of polynomials. Must be polynomials from AbstractAlgebra.jl or Nemo.jl over GF(p) or Native.GF(p).\n\nReturns\n\nReturns a tuple (trace, basis).\n\ntrace: an object, a trace. Can be used in groebner_apply!.\nbasis: an array of polynomials, a Groebner basis.\n\nPossible Options\n\nSame as for groebner.\n\nExample\n\nUsing groebner_learn and groebner_apply! over the same ground field:\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = GF(2^31-1)[\"x\", \"y\"]\n\n# Learn\ntrace, gb_1 = groebner_learn([x*y^2 + x, y*x^2 + y])\n\n# Apply (same support, different coefficients)\nflag, gb_2 = groebner_apply!(trace, [2x*y^2 + 3x, 4y*x^2 + 5y])\n\n@assert flag\n\nUsing groebner_learn and groebner_apply! over different ground fields:\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = GF(2^31-1)[\"x\", \"y\"]\n\n# Learn\ntrace, gb_1 = groebner_learn([x*y^2 + x, y*x^2 + y], ordering=DegRevLex())\n\n# Create a ring with a different modulo\nR2, (x2, y2) = GF(2^30+3)[\"x\", \"y\"]\n\n# Apply (different modulo)\nflag, gb_2 = groebner_apply!(\n    trace, \n    [2x2*y2^2 + 3x2, 4y2*x2^2 + 5y2], \n    ordering=DegRevLex()\n)\n\n@assert flag\n@assert gb_2 == groebner([2x2*y2^2 + 3x2, 4y2*x2^2 + 5y2], ordering=DegRevLex())\n\nUsing groebner_apply! in batches:\n\nusing Groebner, AbstractAlgebra\nR, (x, y) = polynomial_ring(GF(2^31-1), [\"x\", \"y\"], internal_ordering=:degrevlex)\n\n# Learn\ntrace, gb_1 = groebner_learn([x*y^2 + x, y*x^2 + y])\n\n# Create rings with some other moduli\nR2, (x2, y2) = polynomial_ring(GF(2^30+3), [\"x\", \"y\"], internal_ordering=:degrevlex)\nR3, (x3, y3) = polynomial_ring(GF(2^27+29), [\"x\", \"y\"], internal_ordering=:degrevlex)\n\n# Two specializations of the same ideal\nbatch = ([2x2*y2^2 + 3x2, 4y2*x2^2 + 5y2], [4x3*y3^2 + 4x3, 5y3*x3^2 + 7y3])\n\n# Apply for two sets of polynomials at once\nflag, (gb_2, gb_3) = groebner_apply!(trace, batch)\n\n@assert flag\n@assert (gb_2, gb_3) == map(groebner, batch)\n\nPerhaps, in a more involved example, we will compute Groebner bases of the Katsura-9 system:\n\nusing Groebner, AbstractAlgebra, BenchmarkTools\n\n# Create the system\nkat = Groebner.Examples.katsuran(9, k=ZZ, internal_ordering=:degrevlex)\n\n# Reduce the coefficients modulo 5 different primes\nkat_0 = map(f -> map_coefficients(c -> GF(2^30 + 3)(c), f), kat)\nkat_1 = map(f -> map_coefficients(c -> GF(2^30 + 7)(c), f), kat)\nkat_2 = map(f -> map_coefficients(c -> GF(2^30 + 9)(c), f), kat)\nkat_3 = map(f -> map_coefficients(c -> GF(2^30 + 15)(c), f), kat)\nkat_4 = map(f -> map_coefficients(c -> GF(2^30 + 19)(c), f), kat)\n\n# Learn the trace\ntrace, gb_0 = groebner_learn(kat_0);\n\n# Compare the performance of applying with 1 input and with 4 different inputs:\n\n# Apply for one system\n@btime groebner_apply!($trace, $kat_1);\n#  46.824 ms (19260 allocations: 24.48 MiB)\n\n# Apply for a batch of four systems\n@btime groebner_apply!($trace, $(kat_1, kat_2, kat_3, kat_4));\n#  72.813 ms (23722 allocations: 59.44 MiB)\n\nObserve the better amortized performance of the composite groebner_apply!.\n\nNotes\n\nThe function is thread-safe.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Groebner.groebner_apply!","page":"Interface","title":"Groebner.groebner_apply!","text":"groebner_apply!(trace, polynomials; options...)\ngroebner_apply!(trace, batch::NTuple{N, Vector}; options...)\n\nComputes a Groebner basis of the ideal generated by polynomials following the given trace. \n\nSee also groebner_learn.\n\nArguments\n\ntrace: a trace produced by groebner_learn.\npolynomials: an array of polynomials. Must be polynomials from   AbstractAlgebra.jl or Nemo.jl over GF(p) or Nemo.GF(p). It is possible   to supply a tuple of N arrays of polynomials to compute N Groebner bases   simultaneously. This could be more efficient overall than computing them in   separate.\n\nReturns\n\nReturns a tuple (success, basis).\n\nsuccess: a bool, whether the call succeeded.\nbasis: an array of polynomials, a Groebner basis.\n\nPossible Options\n\nThe groebner_apply! function automatically inherits most parameters from the given trace.\n\nExample\n\nFor examples, see the documentation of groebner_learn.\n\nNotes\n\nIn general, success may be a false positive. The probability of a false positive is considered to be low enough in some practical applications.\nThis function is not thread-safe since it mutates trace.\nThis function is not safe against program interruptions. For example,   pressing Ctrl + C while groebner_apply!(trace, ...) is running may leave   trace corrupted.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"Groebner.jl supports polynomials from the following frontends:\n\nAbstractAlgebra.jl\nNemo.jl\nDynamicPolynomials.jl\n\nAdditionally, Groebner.jl has a low-level entry point that accepts raw polynomial data.","category":"section"},{"location":"examples/#Using-AbstractAlgebra.jl","page":"Examples","title":"Using AbstractAlgebra.jl","text":"First, we import AbstractAlgebra.jl.  Then, we create an array of polynomials over a finite field\n\nusing AbstractAlgebra\n\nR, (x, y, z) = polynomial_ring(GF(2^31 - 1), [\"x\", \"y\", \"z\"])\npolys = [x^2 + y + z, x*y + z];\n\nand compute a Gröbner basis with the groebner command\n\nusing Groebner\n\nbasis = groebner(polys)\n\nWe can check if a set of polynomials forms a Gröbner basis\n\nisgroebner(basis)\n\nGroebner.jl also provides several monomial orderings.  For example, we can eliminate z from the above system:\n\nordering = Lex(z) * DegRevLex(x, y)  # z > x, y\ngroebner(polys, ordering=ordering)\n\nYou can find more information on monomial orderings in Groebner.jl in Monomial orderings.","category":"section"},{"location":"examples/#Using-DynamicPolynomials.jl","page":"Examples","title":"Using DynamicPolynomials.jl","text":"Computing the Gröbner basis of some system:\n\nusing DynamicPolynomials, Groebner\n\n@polyvar x1 x2\nsystem = [10*x1*x2^2 - 11*x1 + 10,\n        10*x1^2*x2 - 11*x2 + 10]\n\ngroebner(system)","category":"section"},{"location":"examples/#Using-Low-level-interface","page":"Examples","title":"Using Low-level interface","text":"Some functions in the interface have a low-level entry point. Low-level functions accept and output ''raw'' exponent vectors and coefficients. This could be convenient when one does not want to depend on a frontend.\n\nFor example,\n\nusing Groebner\n\n# define {x * y - 1, x^3 + 7 * y^2} modulo 65537 in DRL\nring = Groebner.PolyRing(2, Groebner.DegRevLex(), 65537)\nmonoms = [ [[1, 1], [0, 0]], [[3, 0], [0, 2]] ]\ncoeffs = [ [    1,     -1 ], [    1,      7 ] ]\n\n# compute a GB\ngb_monoms, gb_coeffs = Groebner.groebner(ring, monoms, coeffs)\n\nThe list of functions that provide a low-level entry point: groebner, normalform, isgroebner, groebner_learn, groebner_apply.\n\nLow-level functions may be faster than their user-facing analogues since they bypass data conversions. Low-level functions do not make any specific assumptions on input polynomials, that is, all of these cases are correctly handled: unsorted monomials, non-normalized coefficients, duplicate terms, aliasing memory.","category":"section"},{"location":"examples/#Generic-coefficients","page":"Examples","title":"Generic coefficients","text":"The implementation in Groebner.jl uses a generic type for coefficients. Hence, in theory, Groebner.jl can compute Gröbner bases over any type that behaves like a field.\n\nFor the following ground fields Groebner.jl runs an efficient native implementation:\n\nintegers modulo a prime,\nrationals numbers.\n\nFor other ground fields, a possibly slower generic fallback is used. In this case, coefficients of polynomials are treated as black-boxes which implement field operations: zero, one, inv, ==, +, *, -.\n\nFor example, we can compute a Gröbner basis over a univariate rational function field over a finite field:\n\nusing Groebner, AbstractAlgebra\n\nR, t = GF(101)[\"t\"]\nff = fraction_field(R)\n_, (x, y) = ff[\"x\",\"y\"]\n\nsys = [(t//t+1)*x*y - t^3, y^2 + t]\n\ngb = groebner(sys)\n\nMany functions reuse the core implementation, so they can also be used over generic fields:\n\n@assert isgroebner(gb)\nnormalform(gb, x*y)","category":"section"},{"location":"examples/#Computing-over-floating-point-intervals","page":"Examples","title":"Computing over floating point intervals","text":"In the following example, we combine low-level interface and generic coefficients. \n\nWe are going to compute a basis of the hexapod system over tuples (Z_p, Interval): each coefficient is treated as a pair, the first coordinate is a finite field element used for zero testing, and the second coordinate is a floating point interval with some fixed precision, the payload. For floating point arithmetic, we will be using MPFI.jl.\n\nusing Pkg;\nPkg.add(url=\"https://gitlab.inria.fr/ckatsama/mpfi.jl\")\n\nimport Base: +, -, *, zero, iszero, one, isone, inv\nusing AbstractAlgebra, Groebner, MPFI\n\nPRECISION = 1024 # For MPFI intervals\n\nstruct Zp_And_FloatInterval{Zp, FloatInterval}\n    a::Zp\n    b::FloatInterval\nend\n\n# Pretend it is a field and hakuna matata\n+(x::Zp_And_FloatInterval, y::Zp_And_FloatInterval) = Zp_And_FloatInterval(x.a + y.a, x.b + y.b)\n*(x::Zp_And_FloatInterval, y::Zp_And_FloatInterval) = Zp_And_FloatInterval(x.a * y.a, x.b * y.b)\n-(x::Zp_And_FloatInterval, y::Zp_And_FloatInterval) = Zp_And_FloatInterval(x.a - y.a, x.b - y.b)\nzero(x::Zp_And_FloatInterval) = Zp_And_FloatInterval(zero(x.a), zero(x.b))\none(x::Zp_And_FloatInterval) = Zp_And_FloatInterval(one(x.a), one(x.b))\ninv(x::Zp_And_FloatInterval) = Zp_And_FloatInterval(inv(x.a), inv(x.b))\niszero(x::Zp_And_FloatInterval) = iszero(x.a)\nisone(x::Zp_And_FloatInterval) = isone(x.a)\n\n@info \"Computing Hexapod over QQ\"\nc_zp = Groebner.Examples.hexapod(k=AbstractAlgebra.GF(2^30+3));\nc_qq = Groebner.Examples.hexapod(k=AbstractAlgebra.QQ);\n@time gb_truth = groebner(c_qq);\ngbcoeffs_truth = map(f -> collect(coefficients(f)), gb_truth);\n@info \"Coefficient size (in bits): $(maximum(f -> maximum(c -> log2(abs(numerator(c))) + log2(denominator(c)), f), gbcoeffs_truth))\"\n\n@info \"Computing Hexapod over (Zp, Interval). Precision = $PRECISION bits\"\nring = Groebner.PolyRing(nvars(parent(c_qq[1])), Groebner.DegRevLex(), 0, :generic); # Note :generic\nexps = map(f -> collect(exponent_vectors(f)), c_zp);\ncfs_qq = map(f -> collect(coefficients(f)), c_qq);\ncfs_zp = map(f -> collect(coefficients(f)), c_zp);\ncfs = map(f -> map(c -> Groebner.CoeffGeneric(Zp_And_FloatInterval(c[1], BigInterval(c[2], precision=PRECISION))), zip(f...)), zip(cfs_zp, cfs_qq));\n@time gbexps, gbcoeffs = groebner(ring, exps, cfs);\n\nto_inspect = gbcoeffs[end][end]\n@info \"\n    Inspect one coefficient in the basis:\n    Zp         = $(to_inspect.data.a)\n    Interval   = $(to_inspect.data.b)\n    Diam       = $(diam(to_inspect.data.b))\n    Diam (rel) = $(diam_rel(to_inspect.data.b))\"\n\n# Sanity check\nall_are_inside(x::Zp_And_FloatInterval, truth) = is_inside(BigInterval(truth; precision=PRECISION), x.b)\nall_are_inside(x::Groebner.CoeffGeneric, truth) = all_are_inside(x.data, truth)\nall_are_inside(x::AbstractVector, truth) = all(map(all_are_inside, x, truth))\n@assert all_are_inside(gbcoeffs, gbcoeffs_truth)\n\n# Max |midpoint - truth|\nmax_error(x::Zp_And_FloatInterval, y; rel=false) = abs(mid(x.b) - y) / ifelse(rel, max(abs(y), 0), 1)\nmax_error(x::Groebner.CoeffGeneric, y; rel=false) = max_error(x.data, y; rel=rel)\nmax_error(x::AbstractVector, y::AbstractVector; rel=false) = maximum(map(f -> max_error(f...; rel=rel), zip(x, y)))\n@info \"\n    Max error      : $(max_error(gbcoeffs, gbcoeffs_truth))\n    Max error (rel): $(max_error(gbcoeffs, gbcoeffs_truth; rel=true))\"\n\n# Max diameter\nmax_diam(x::Zp_And_FloatInterval; rel=false) = ifelse(rel, diam_rel(x.b), diam(x.b))\nmax_diam(x::Groebner.CoeffGeneric; rel=false) = max_diam(x.data; rel=rel)\nmax_diam(x::AbstractVector; rel=false) = maximum(map(f -> max_diam(f; rel=rel), x))\n@info \"\n    Max diam      : $(max_diam(gbcoeffs))\n    Max diam (rel): $(max_diam(gbcoeffs; rel=true))\"\n\nHowever, if we lower MPFI precision to 256 bits, some of the intervals become NaN.","category":"section"},{"location":"#Home","page":"Home","title":"Home","text":"Groebner.jl is a package for computing Gröbner bases written in Julia.\n\nnote: Note\nThis documentation is also available in PDF format: Groebner.jl.pdf.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install Groebner.jl, run the following in the Julia REPL:\n\nusing Pkg; Pkg.add(\"Groebner\")","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Groebner.jl features:\n\nGröbner basis over integers modulo a prime and over the rationals\nGröbner trace algorithms\nMulti-threading","category":"section"},{"location":"#Contacts","page":"Home","title":"Contacts","text":"This library is maintained by Alexander Demin (asdemin_2@edu.hse.ru).","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"@misc{demin2024groebnerjl,\n      title={Groebner.jl: A package for Gr\\\"obner bases computations in Julia}, \n      author={Alexander Demin and Shashi Gowda},\n      year={2024},\n      eprint={2304.06935},\n      archivePrefix={arXiv},\n      primaryClass={cs.MS}\n}","category":"section"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"We would like to acknowledge the developers of the msolve library (https://msolve.lip6.fr/), as several components of Groebner.jl were adapted from msolve. In our F4 implementation, we adapt and adjust the code of monomial hashtable, critical pair handling and symbolic preprocessing, and linear algebra from msolve. The source code of msolve is available at https://github.com/algebraic-solving/msolve.\n\nWe thank Vladimir Kuznetsov for helpful discussions and providing the sources of his F4 implementation.\n\nWe are grateful to The Max Planck Institute for Informatics, The MAX team at l'X, and the OURAGAN team at Inria for providing computational resources.","category":"section"}]
}
